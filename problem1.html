<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theoremica - Visual Proof Builder</title>

    <!-- Load Blockly from CDN -->
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
        }

        #header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 24px;
        }

        #exportButton {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        #exportButton:hover {
            background-color: #2980b9;
        }

        #exportButton:active {
            background-color: #21618c;
        }

        #mainContainer {
            display: flex;
            height: calc(100vh - 64px);
        }

        #blocklyDiv {
            flex: 1;
            height: 100%;
        }

        #outputPanel {
            width: 350px;
            background-color: white;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            padding: 20px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
        }

        #outputPanel h2 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        #infoPanel {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
            line-height: 1.6;
            color: #2c3e50;
        }

        #infoPanel h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 16px;
        }

        #infoPanel p {
            margin: 10px 0;
            font-size: 14px;
        }

        #infoPanel ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        #infoPanel li {
            margin: 8px 0;
            font-size: 14px;
        }

        #infoPanel code {
            background-color: #d5d8dc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        #verificationStatus {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 5px;
            color: rgb(249, 245, 245);
            font-weight: bold;
            text-align: center;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        #verificationStatus.success {
            background-color: #27ae60;
        }

        #verificationStatus.error {
            background-color: #e74c3c;
        }

        #verificationStatus.loading {
            background-color: #f39c12;
        }

        #verificationStatus.ready {
            background-color: #95a5a6;
        }

        .verification-message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
        }

        .verification-message.valid {
            background-color: #27ae60;
        }

        .verification-message.invalid {
            background-color: #e74c3c;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background-color: #2ecc71;
        }

        .status-indicator.disconnected {
            background-color: #e74c3c;
        }

        #serverStatus {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <!-- Header with title and export button -->
    <div id="header">
        <h1>üìê Theoremica - Visual Proof Builder</h1>
        <button id="exportButton" type="button">Check Solution</button>
    </div>

    <!-- Main container with Blockly workspace and output panel -->
    <div id="mainContainer">
        <div id="blocklyDiv"></div>
        <div id="outputPanel">
            <h2>Prove:</h2>
            <div id="infoPanel">
                <h3>Statement</h3>
                <p>Prove:</p>

                <h3> How to Use</h3>
                <ul>
                    <li>Drag <code>Assume</code> blocks for your hypotheses</li>
                    <li>Add <code>Therefore</code> blocks for logical steps</li>
                    <li>End with a <code>QED</code> block</li>
                    <li>Click "Check Solution" to generate Lean 4 code</li>
                </ul>

                <div id="verificationStatus" class="ready">
                    Ready to verify
                </div>

                <div id="serverStatus">
                    <span class="status-indicator disconnected" id="statusDot"></span>
                    <span id="statusText">Checking backend connection...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Import custom block definitions -->
    <script src="blocks.js"></script>

    <script>
        // ============================================================================
        // BLOCKLY WORKSPACE CONFIGURATION
        // ============================================================================

        /**
         * Define the toolbox (palette of available blocks)
         * Users can drag these blocks into the workspace
         */
        const toolbox = {
            "kind": "categoryToolbox",
            "contents": [
                {
                    "kind": "category",
                    "name": "Basic Proof",
                    "colour": "230",
                    "contents": [
                        {
                            "kind": "block",
                            "type": "proof_assume"
                        },
                        {
                            "kind": "block",
                            "type": "proof_therefore"
                        },
                        {
                            "kind": "block",
                            "type": "proof_qed"
                        }
                    ]
                },
                {
                    "kind": "category",
                    "name": "Logical Symbols",
                    "colour": "230",
                    "contents": [
                        {
                            "kind": "block",
                            "type": "logic_forall"
                        },
                        {
                            "kind": "block",
                            "type": "logic_exists"
                        },
                        {
                            "kind": "block",
                            "type": "logic_implies"
                        },
                        {
                            "kind": "block",
                            "type": "logic_iff"
                        },
                        {
                            "kind": "block",
                            "type": "logic_not"
                        },
                        {
                            "kind": "block",
                            "type": "logic_and"
                        },
                        {
                            "kind": "block",
                            "type": "logic_or"
                        },
                        {
                            "kind": "block",
                            "type": "logic_eq"
                        },
                        {
                            "kind": "block",
                            "type": "logic_neq"
                        }
                    ]
                },
                {
                    "kind": "category",
                    "name": "Set & Relation",
                    "colour": "45",
                    "contents": [
                        {
                            "kind": "block",
                            "type": "set_elem"
                        },
                        {
                            "kind": "block",
                            "type": "set_not_elem"
                        },
                        {
                            "kind": "block",
                            "type": "set_subset"
                        },
                        {
                            "kind": "block",
                            "type": "set_proper_subset"
                        },
                        {
                            "kind": "block",
                            "type": "set_union"
                        },
                        {
                            "kind": "block",
                            "type": "set_intersection"
                        },
                        {
                            "kind": "block",
                            "type": "set_difference"
                        },
                        {
                            "kind": "block",
                            "type": "set_empty"
                        },
                        {
                            "kind": "label",
                            "text": "Number Sets"
                        },
                        {
                            "kind": "block",
                            "type": "set_naturals"
                        },
                        {
                            "kind": "block",
                            "type": "set_integers"
                        },
                        {
                            "kind": "block",
                            "type": "set_rationals"
                        },
                        {
                            "kind": "block",
                            "type": "set_reals"
                        },
                        {
                            "kind": "block",
                            "type": "set_function"
                        }
                    ]
                },
                {
                    "kind": "category",
                    "name": "Arithmetic",
                    "colour": "290",
                    "contents": [
                        {
                            "kind": "block",
                            "type": "arith_add"
                        },
                        {
                            "kind": "block",
                            "type": "arith_sub"
                        },
                        {
                            "kind": "block",
                            "type": "arith_mul"
                        },
                        {
                            "kind": "block",
                            "type": "arith_div"
                        },
                        {
                            "kind": "block",
                            "type": "arith_pow"
                        },
                        {
                            "kind": "label",
                            "text": "Number Theory"
                        },
                        {
                            "kind": "block",
                            "type": "arith_divides"
                        },
                        {
                            "kind": "block",
                            "type": "arith_mod"
                        },
                        {
                            "kind": "label",
                            "text": "Comparisons"
                        },
                        {
                            "kind": "block",
                            "type": "arith_le"
                        },
                        {
                            "kind": "block",
                            "type": "arith_lt"
                        },
                        {
                            "kind": "block",
                            "type": "arith_ge"
                        },
                        {
                            "kind": "block",
                            "type": "arith_gt"
                        }
                    ]
                },
                {
                    "kind": "category",
                    "name": "Proof Tactics",
                    "colour": "120",
                    "contents": [
                        {
                            "kind": "block",
                            "type": "tactic_assume"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_suppose"
                        },
                        {
                            "kind": "label",
                            "text": "Case Analysis"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_case"
                        },
                        {
                            "kind": "label",
                            "text": "Structuring"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_then"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_let"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_use"
                        },
                        {
                            "kind": "label",
                            "text": "Logical Operations"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_split"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_left"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_right"
                        },
                        {
                            "kind": "label",
                            "text": "Basic Tactics"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_simp"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_rfl"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_contradiction"
                        },
                        {
                            "kind": "block",
                            "type": "tactic_apply"
                        }
                    ]
                }
            ]
        };

        /**
         * Initialize the Blockly workspace
         */
        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: toolbox,
            grid: {
                spacing: 20,
                length: 3,
                colour: '#ccc',
                snap: true
            },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.3,
                scaleSpeed: 1.2
            },
            trashcan: true,
            scrollbars: true
        });

        // Persist workspace to localStorage to avoid resets
        const STORAGE_KEY = 'theoremica_workspace_xml_v1';

        function domToTextSafe(xmlDom) {
            try {
                if (Blockly.Xml && typeof Blockly.Xml.domToText === 'function') {
                    return Blockly.Xml.domToText(xmlDom);
                }
                if (Blockly.utils && Blockly.utils.xml && typeof Blockly.utils.xml.domToText === 'function') {
                    return Blockly.utils.xml.domToText(xmlDom);
                }
                const serializer = new XMLSerializer();
                return serializer.serializeToString(xmlDom);
            } catch (e) {
                throw e;
            }
        }

        function textToDomSafe(text) {
            try {
                if (Blockly.Xml && typeof Blockly.Xml.textToDom === 'function') {
                    return Blockly.Xml.textToDom(text);
                }
                if (Blockly.utils && Blockly.utils.xml && typeof Blockly.utils.xml.textToDom === 'function') {
                    return Blockly.utils.xml.textToDom(text);
                }
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/xml');
                return doc.documentElement;
            } catch (e) {
                throw e;
            }
        }

        function saveWorkspace() {
            try {
                // Only save if there are blocks; prevents wiping saved layout
                const hasBlocks = workspace.getAllBlocks(false).length > 0;
                if (!hasBlocks) return;

                const xml = Blockly.Xml.workspaceToDom(workspace);
                const text = domToTextSafe(xml);
                localStorage.setItem(STORAGE_KEY, text);
            } catch (e) {
                console.warn('Unable to save workspace:', e);
            }
        }

        function loadWorkspace() {
            try {
                const text = localStorage.getItem(STORAGE_KEY);
                if (text && text.length > 0) {
                    const xml = textToDomSafe(text);
                    workspace.clear();
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    return true;
                }
            } catch (e) {
                console.warn('Unable to load workspace:', e);
            }
            return false;
        }

        // (Moved) Auto-save listener will be attached after restore/init below

        // ============================================================================
        // PROOF EXTRACTION AND DISPLAY LOGIC
        // ============================================================================

        /**
         * Extract all blocks from the workspace and return them as a structured array
         * This function traverses the block chain starting from top-level blocks
         */
        function extractProofSteps() {
            const allBlocks = workspace.getAllBlocks(false);  // false = ordered by position
            const proofSteps = [];

            // Find all top-level blocks (blocks without a parent connection)
            const topBlocks = allBlocks.filter(block => !block.previousConnection?.targetBlock());

            // For each top-level block, traverse down the chain
            topBlocks.forEach(topBlock => {
                let currentBlock = topBlock;

                // Follow the chain of connected blocks
                while (currentBlock) {
                    const blockType = currentBlock.type;
                    let stepInfo = {
                        type: blockType,
                        data: {}
                    };

                    // Extract data based on block type
                    if (blockType === 'proof_assume') {
                        stepInfo.data.statement = currentBlock.getFieldValue('STATEMENT');
                        stepInfo.label = 'Assume';
                    } else if (blockType === 'proof_therefore') {
                        stepInfo.data.conclusion = currentBlock.getFieldValue('CONCLUSION');
                        stepInfo.label = 'Therefore';
                    } else if (blockType === 'proof_qed') {
                        stepInfo.label = 'QED';
                    }
                    // Logical Symbols
                    else if (blockType === 'logic_forall') {
                        stepInfo.data.var = currentBlock.getFieldValue('VAR');
                        stepInfo.data.expr = currentBlock.getFieldValue('EXPR');
                        stepInfo.label = '‚àÄ';
                    } else if (blockType === 'logic_exists') {
                        stepInfo.data.var = currentBlock.getFieldValue('VAR');
                        stepInfo.data.expr = currentBlock.getFieldValue('EXPR');
                        stepInfo.label = '‚àÉ';
                    } else if (blockType === 'logic_implies') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚Üí';
                    } else if (blockType === 'logic_iff') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚Üî';
                    } else if (blockType === 'logic_not') {
                        stepInfo.data.expr = currentBlock.getFieldValue('EXPR');
                        stepInfo.label = '¬¨';
                    } else if (blockType === 'logic_and') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚àß';
                    } else if (blockType === 'logic_or') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚à®';
                    } else if (blockType === 'logic_eq') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '=';
                    } else if (blockType === 'logic_neq') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚â†';
                    }
                    // Set & Relation Symbols
                    else if (blockType === 'set_elem') {
                        stepInfo.data.elem = currentBlock.getFieldValue('ELEM');
                        stepInfo.data.set = currentBlock.getFieldValue('SET');
                        stepInfo.label = '‚àà';
                    } else if (blockType === 'set_not_elem') {
                        stepInfo.data.elem = currentBlock.getFieldValue('ELEM');
                        stepInfo.data.set = currentBlock.getFieldValue('SET');
                        stepInfo.label = '‚àâ';
                    } else if (blockType === 'set_subset') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚äÜ';
                    } else if (blockType === 'set_proper_subset') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚äÇ';
                    } else if (blockType === 'set_union') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚à™';
                    } else if (blockType === 'set_intersection') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚à©';
                    } else if (blockType === 'set_difference') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '\\';
                    } else if (blockType === 'set_empty') {
                        stepInfo.label = '‚àÖ';
                    } else if (blockType === 'set_naturals') {
                        stepInfo.label = '‚Ñï';
                    } else if (blockType === 'set_integers') {
                        stepInfo.label = '‚Ñ§';
                    } else if (blockType === 'set_rationals') {
                        stepInfo.label = '‚Ñö';
                    } else if (blockType === 'set_reals') {
                        stepInfo.label = '‚Ñù';
                    } else if (blockType === 'set_function') {
                        stepInfo.data.func = currentBlock.getFieldValue('FUNC');
                        stepInfo.data.arg = currentBlock.getFieldValue('ARG');
                        stepInfo.label = 'function';
                    }
                    // Arithmetic & Number Theory
                    else if (blockType === 'arith_add') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '+';
                    } else if (blockType === 'arith_sub') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '-';
                    } else if (blockType === 'arith_mul') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '*';
                    } else if (blockType === 'arith_div') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '/';
                    } else if (blockType === 'arith_pow') {
                        stepInfo.data.base = currentBlock.getFieldValue('BASE');
                        stepInfo.data.exp = currentBlock.getFieldValue('EXP');
                        stepInfo.label = '^';
                    } else if (blockType === 'arith_divides') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚à£';
                    } else if (blockType === 'arith_mod') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.middle = currentBlock.getFieldValue('MIDDLE');
                        stepInfo.data.modulus = currentBlock.getFieldValue('MODULUS');
                        stepInfo.label = '‚â°';
                    } else if (blockType === 'arith_le') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚â§';
                    } else if (blockType === 'arith_lt') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '<';
                    } else if (blockType === 'arith_ge') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '‚â•';
                    } else if (blockType === 'arith_gt') {
                        stepInfo.data.left = currentBlock.getFieldValue('LEFT');
                        stepInfo.data.right = currentBlock.getFieldValue('RIGHT');
                        stepInfo.label = '>';
                    }
                    // Proof Tactics
                    else if (blockType === 'tactic_assume') {
                        stepInfo.data.var = currentBlock.getFieldValue('VAR');
                        stepInfo.data.prop = currentBlock.getFieldValue('PROP');
                        stepInfo.label = 'Assume';
                    } else if (blockType === 'tactic_suppose') {
                        stepInfo.data.var = currentBlock.getFieldValue('VAR');
                        stepInfo.data.prop = currentBlock.getFieldValue('PROP');
                        stepInfo.label = 'Suppose';
                    } else if (blockType === 'tactic_case') {
                        stepInfo.data.case = currentBlock.getFieldValue('CASE');
                        stepInfo.label = 'Case';
                    } else if (blockType === 'tactic_then') {
                        stepInfo.data.step = currentBlock.getFieldValue('STEP');
                        stepInfo.label = 'Then';
                    } else if (blockType === 'tactic_let') {
                        stepInfo.data.var = currentBlock.getFieldValue('VAR');
                        stepInfo.data.expr = currentBlock.getFieldValue('EXPR');
                        stepInfo.label = 'Let';
                    } else if (blockType === 'tactic_use') {
                        stepInfo.data.witness = currentBlock.getFieldValue('WITNESS');
                        stepInfo.label = 'Use';
                    } else if (blockType === 'tactic_split') {
                        stepInfo.label = 'Split';
                    } else if (blockType === 'tactic_left') {
                        stepInfo.label = 'Left';
                    } else if (blockType === 'tactic_right') {
                        stepInfo.label = 'Right';
                    } else if (blockType === 'tactic_simp') {
                        stepInfo.label = 'Simplify';
                    } else if (blockType === 'tactic_rfl') {
                        stepInfo.label = 'Reflexivity';
                    } else if (blockType === 'tactic_contradiction') {
                        stepInfo.label = 'Contradiction';
                    } else if (blockType === 'tactic_apply') {
                        stepInfo.data.theorem = currentBlock.getFieldValue('THEOREM');
                        stepInfo.label = 'Apply';
                    }

                    proofSteps.push(stepInfo);

                    // Move to the next connected block
                    currentBlock = currentBlock.nextConnection?.targetBlock();
                }
            });

            return proofSteps;
        }

        /**
         * Convert proof steps to natural language text format
         * This format is optimized for LLM consumption
         */
        function convertToNaturalLanguage(steps) {
            if (steps.length === 0) {
                return "No proof blocks found. Please build your proof first.";
            }

            let text = "Proof Structure:\n";

            steps.forEach((step, index) => {
                if (step.type === 'proof_assume') {
                    text += `- Assume: ${step.data.statement}\n`;
                } else if (step.type === 'proof_therefore') {
                    text += `- Therefore: ${step.data.conclusion}\n`;
                } else if (step.type === 'proof_qed') {
                    text += `- QED\n`;
                }
                // Logical Symbols
                else if (step.type === 'logic_forall') {
                    text += `- ‚àÄ ${step.data.var}, ${step.data.expr}\n`;
                } else if (step.type === 'logic_exists') {
                    text += `- ‚àÉ ${step.data.var}, ${step.data.expr}\n`;
                } else if (step.type === 'logic_implies') {
                    text += `- ${step.data.left} ‚Üí ${step.data.right}\n`;
                } else if (step.type === 'logic_iff') {
                    text += `- ${step.data.left} ‚Üî ${step.data.right}\n`;
                } else if (step.type === 'logic_not') {
                    text += `- ¬¨ ${step.data.expr}\n`;
                } else if (step.type === 'logic_and') {
                    text += `- ${step.data.left} ‚àß ${step.data.right}\n`;
                } else if (step.type === 'logic_or') {
                    text += `- ${step.data.left} ‚à® ${step.data.right}\n`;
                } else if (step.type === 'logic_eq') {
                    text += `- ${step.data.left} = ${step.data.right}\n`;
                } else if (step.type === 'logic_neq') {
                    text += `- ${step.data.left} ‚â† ${step.data.right}\n`;
                }
                // Set & Relation
                else if (step.type === 'set_elem') {
                    text += `- ${step.data.elem} ‚àà ${step.data.set}\n`;
                } else if (step.type === 'set_not_elem') {
                    text += `- ${step.data.elem} ‚àâ ${step.data.set}\n`;
                } else if (step.type === 'set_subset') {
                    text += `- ${step.data.left} ‚äÜ ${step.data.right}\n`;
                } else if (step.type === 'set_proper_subset') {
                    text += `- ${step.data.left} ‚äÇ ${step.data.right}\n`;
                } else if (step.type === 'set_union') {
                    text += `- ${step.data.left} ‚à™ ${step.data.right}\n`;
                } else if (step.type === 'set_intersection') {
                    text += `- ${step.data.left} ‚à© ${step.data.right}\n`;
                } else if (step.type === 'set_difference') {
                    text += `- ${step.data.left} \\ ${step.data.right}\n`;
                } else if (step.type === 'set_empty') {
                    text += `- ‚àÖ\n`;
                } else if (step.type === 'set_naturals') {
                    text += `- ‚Ñï (Natural numbers)\n`;
                } else if (step.type === 'set_integers') {
                    text += `- ‚Ñ§ (Integers)\n`;
                } else if (step.type === 'set_rationals') {
                    text += `- ‚Ñö (Rationals)\n`;
                } else if (step.type === 'set_reals') {
                    text += `- ‚Ñù (Real numbers)\n`;
                } else if (step.type === 'set_function') {
                    text += `- ${step.data.func}(${step.data.arg})\n`;
                }
                // Arithmetic & Number Theory
                else if (step.type === 'arith_add') {
                    text += `- ${step.data.left} + ${step.data.right}\n`;
                } else if (step.type === 'arith_sub') {
                    text += `- ${step.data.left} - ${step.data.right}\n`;
                } else if (step.type === 'arith_mul') {
                    text += `- ${step.data.left} * ${step.data.right}\n`;
                } else if (step.type === 'arith_div') {
                    text += `- ${step.data.left} / ${step.data.right}\n`;
                } else if (step.type === 'arith_pow') {
                    text += `- ${step.data.base} ^ ${step.data.exp}\n`;
                } else if (step.type === 'arith_divides') {
                    text += `- ${step.data.left} ‚à£ ${step.data.right}\n`;
                } else if (step.type === 'arith_mod') {
                    text += `- ${step.data.left} ‚â° ${step.data.middle} [MOD ${step.data.modulus}]\n`;
                } else if (step.type === 'arith_le') {
                    text += `- ${step.data.left} ‚â§ ${step.data.right}\n`;
                } else if (step.type === 'arith_lt') {
                    text += `- ${step.data.left} < ${step.data.right}\n`;
                } else if (step.type === 'arith_ge') {
                    text += `- ${step.data.left} ‚â• ${step.data.right}\n`;
                } else if (step.type === 'arith_gt') {
                    text += `- ${step.data.left} > ${step.data.right}\n`;
                }
                // Proof Tactics
                else if (step.type === 'tactic_assume') {
                    text += `- Assume ${step.data.var}: ${step.data.prop}\n`;
                } else if (step.type === 'tactic_suppose') {
                    text += `- Suppose ${step.data.var}: ${step.data.prop}\n`;
                } else if (step.type === 'tactic_case') {
                    text += `- Case ${step.data.case}:\n`;
                } else if (step.type === 'tactic_then') {
                    text += `- Then: ${step.data.step}\n`;
                } else if (step.type === 'tactic_let') {
                    text += `- Let ${step.data.var} := ${step.data.expr}\n`;
                } else if (step.type === 'tactic_use') {
                    text += `- Use ${step.data.witness}\n`;
                } else if (step.type === 'tactic_split') {
                    text += `- Split\n`;
                } else if (step.type === 'tactic_left') {
                    text += `- Left\n`;
                } else if (step.type === 'tactic_right') {
                    text += `- Right\n`;
                } else if (step.type === 'tactic_simp') {
                    text += `- Simplify\n`;
                } else if (step.type === 'tactic_rfl') {
                    text += `- Reflexivity\n`;
                } else if (step.type === 'tactic_contradiction') {
                    text += `- Contradiction\n`;
                } else if (step.type === 'tactic_apply') {
                    text += `- Apply ${step.data.theorem}\n`;
                }
            });

            text += "\nGenerate Lean 4 code for this proof.";

            return text;
        }

        /**
         * Download text content as a file
         */
        function downloadTextFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        /**
         * Send proof to Python backend for Lean 4 conversion
         */
        async function sendToBackend(proofText) {
            const backendUrl = '/jobs';

            const response = await fetch(backendUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    proof_text: proofText
                })
            });

            if (!response.ok) {
                throw new Error(`Backend error: ${response.status}`);
            }

            // returns { job_id }
            return response.json();
        }

        // Simple architecture: no latest_result, no sockets; job polling only

        /**
         * Check if backend server is running
         **/
        async function checkBackendConnection() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    document.getElementById('statusDot').className = 'status-indicator connected';
                    document.getElementById('statusText').textContent = 'Backend connected';
                    return true;
                } else {
                    document.getElementById('statusDot').className = 'status-indicator disconnected';
                    document.getElementById('statusText').textContent = 'Backend error - Check server.py';
                    return false;
                }
            } catch (error) {
                document.getElementById('statusDot').className = 'status-indicator disconnected';
                document.getElementById('statusText').textContent = 'Backend disconnected - Start server.py';
                return false;
            }
        }

        let isVerifying = false;
        const button = document.getElementById('exportButton');

        /**
         * Handle "Check Solution" button click
         * Sends proof to Python backend for verification
         */
        document.getElementById('exportButton').addEventListener('click', async function () {
            const statusDiv = document.getElementById('verificationStatus');

            if (isVerifying) {
                console.log('Already verifying, please wait...');
                return;
            }
            isVerifying = true;
            button.disabled = true;
            button.style.opacity = '0.5';
            button.style.cursor = 'not-allowed';

            // Show loading state
            statusDiv.className = 'loading';
            statusDiv.textContent = 'Verifying proof... (may take up to ~60s)';

            try {
                // Extract proof steps from workspace
                const proofSteps = extractProofSteps();

                // Convert to natural language
                const proofText = convertToNaturalLanguage(proofSteps);

                // Create async job
                const { job_id } = await sendToBackend(proofText);

                // Poll job status until completed (simple, robust)
                let result;
                const start = Date.now();
                while (Date.now() - start < 120000) {
                    const resp = await fetch(`/jobs/${job_id}`, { cache: 'no-store' });
                    if (!resp.ok) throw new Error('Failed to fetch job status');
                    const job = await resp.json();
                    if (job.status === 'running') {
                        statusDiv.textContent = 'Verifying proof...';
                    }
                    if (job.status === 'completed') {
                        result = job.result;
                        break;
                    } else if (job.status === 'failed') {
                        throw new Error(job.error || 'Verification failed');
                    }
                    await new Promise(r => setTimeout(r, 2000));
                }
                if (!result) throw new Error('Timed out waiting for result');

                // Update UI based on validation result
                if (result.valid === true) {
                    statusDiv.className = 'success';
                    statusDiv.textContent = '‚úì Proof is valid!';
                } else {
                    statusDiv.className = 'error';
                    statusDiv.textContent = '‚úó Proof is invalid';
                }

                // Log the generated Lean code
                console.log('Generated Lean code:');
                console.log(result.lean_code);

            } catch (error) {
                statusDiv.className = 'error';
                statusDiv.textContent = '‚úó Error: ' + error.message;
                console.error('Verification error:', error);
            } finally {
                isVerifying = false;
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            }
        });

        // Check backend connection on page load
        checkBackendConnection();
        //setInterval(checkBackendConnection, 5000); // Check every 5 seconds 

        // ============================================================================
        // INITIAL EXAMPLE (Optional - remove if you want a blank workspace)
        // ============================================================================

        /**
         * Create a simple example proof on startup to demonstrate the interface
         * Users can delete these blocks and create their own proof
         */
        function createExampleProof() {
            const assumeBlock = workspace.newBlock('proof_assume');
            assumeBlock.setFieldValue('x > 0 and y > 0', 'STATEMENT');
            assumeBlock.initSvg();
            assumeBlock.render();
            assumeBlock.moveBy(100, 50);

            const thereforeBlock = workspace.newBlock('proof_therefore');
            thereforeBlock.setFieldValue('x + y > 0', 'CONCLUSION');
            thereforeBlock.initSvg();
            thereforeBlock.render();

            // Connect the blocks
            thereforeBlock.previousConnection.connect(assumeBlock.nextConnection);

            const qedBlock = workspace.newBlock('proof_qed');
            qedBlock.initSvg();
            qedBlock.render();

            // Connect QED to the therefore block
            qedBlock.previousConnection.connect(thereforeBlock.nextConnection);
        }

        // Restore saved workspace if available; otherwise create example
        const restored = loadWorkspace();
        if (!restored) {
            createExampleProof();
            // Save initial example so accidental reloads keep it
            saveWorkspace();
        }

        // Attach auto-save AFTER restore/init to avoid overwriting with empty state
        workspace.addChangeListener(function () {
            saveWorkspace();
        });

        console.log("Theoremica Visual Proof Builder loaded successfully!");
        console.log("Drag blocks from the toolbox to build your proof");
        console.log("Click 'Check Solution' to generate natural language for AI");

    </script>
</body>

</html>